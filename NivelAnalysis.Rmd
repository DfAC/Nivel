---
title: "Nivel analysis"
author: "LKB"
output: html_document
---

```{r introSettings, message=FALSE, warning=FALSE}
setwd("d:/Tower/02Processing/Nivel/")


#set std for knitr => http://yihui.name/knitr/options/
library(knitr)
opts_chunk$set(echo = FALSE, cache = T, cache.path = "cache/", fig.path = "figure/", warning = FALSE,error=FALSE,message=F,strip.white=T)
```

This is R code is processing [Leica Nivel 220](http://www.leica-geosystems.co.uk/en/Leica-Nivel210Nivel220_33357.htm) data collected using [port sniffer](https://technet.microsoft.com/en-us/sysinternals/bb896644). Data read has been pre-processed using Unix tools.


## Reading Data

* values +9.999 indicate readings out of scale
* Bridge axis is along the bridge (E) and to left (N). Nivelator axis are y along and x across but opposite to RTS coordinates.



```{r}
library("splitstackshape")
DataUrl<-file.path(getwd(),"Nivel220.out")
Data = read.table(DataUrl,header = F,sep = ",",strip.white=TRUE, stringsAsFactors = F, na.strings = c('9.999') )

```

{Change code from here!}

Lets now clean the data:

* properly split columns 3-5
* change Unix time to seconds
* drop and rename columns
* remove rows with at least one missing data
* mrads to $\frac{mm}{m} using $1000tg(\frac{\alpha}{1000})$

```{r}
Data <- cSplit(Data, c("V3","V4"), c(":"), drop = TRUE, stripWhite= TRUE, type.convert = F)
#drop
Data[,c("V3_1","V4_1")]<-list(NULL)
#rename
columnNames = c("Time","ClockTime","temperature","across","along")
colnames(Data)<-columnNames

Data$ClockTime<-as.POSIXct(Data$ClockTime, format="%H:%M:%S")
Data$Time <- Data$Time/100
Data$across<-1000*tan(as.numeric(Data$across)/1000)
Data$along<-1000*tan(as.numeric(Data$along)/1000)
Data$temperature<-as.numeric(substr(Data$temperature,3,7))

#remove rows with at least one missing data
Data<-Data[complete.cases(Data)]
```


# Understanding data

## have we got axis properly?

```{r}
plot(Data$across,Data$along,col = rgb(100,0,0,50, maxColorValue = 255), asp =1, main = "Data spread")

```

Also note that we don't have any outlayers

## Is our time correct

* Check if differnces between epochs are constant

```{r timeOffset, echo=F}

#function accepts vectors
getEpochDifference<- function(timeSeries){

  epochDifference = ((timeSeries[1:(length(timeSeries)-1)]-timeSeries[2:(length(timeSeries))]))
  
return(epochDifference)
}
```


```{r}

unixTimeDifference = getEpochDifference(Data$Time)
CPUTimeDiff = getEpochDifference(Data$ClockTime)

plot(CPUTimeDiff,type='p',col = rgb(00,100,0,50, maxColorValue = 255), main = "Time difference between epochs",ylab = "time diff [s]")
lines(unixTimeDifference,col = rgb(100,00,0,50, maxColorValue = 255))


```

* check if both times have same duration

```{r}
Data$Time[length(Data$Time)]-Data$Time[1]
as.numeric(Data$ClockTime[length(Data$ClockTime)]-Data$ClockTime[1])*60

```
Thats a bit strage, lets drop first value, as it seems a bit off

```{r}
test = Data
Data = Data[-1] #remove first column
Data$Time[length(Data$Time)]-Data$Time[1]
as.numeric(Data$ClockTime[length(Data$ClockTime)]-Data$ClockTime[1])*60
```

Still off, well need further research


# Time series

Cross plots

```{r}
#plot(Data)
```



```{r}
plot(Data$Time,Data$across,type='l',col = rgb(100,0,0,50, maxColorValue = 255), main = "Time series",xlab = "time [s]", ylab = "movement [mrad]")
lines(Data$along,axes=T,col = rgb(00,100,0,50, maxColorValue = 255))

```




## Working on drift

```{r}
plot(Data$Time,Data$along, main = "Time series",xlab = "Time [s]", ylab = "Along [mrad]")
#dev.copy(png,file = "plot1_time.png",width = 980, height = 980, units = "px", pointsize = 25)
#dev.off() #close device
```

